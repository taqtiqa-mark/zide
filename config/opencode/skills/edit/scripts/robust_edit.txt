#!/usr/bin/env bash
set -euo pipefail

# === robust_edit.sh – the ONLY script allowed to touch files ===
# Two-step workflow: prepare → edit → finalise

while [[ $# -gt 0 ]]; do
  case $1 in
    --target) TARGET="$2"; shift 2 ;;
    --mode)   MODE="${2,,}"; shift 2 ;;
    --step)   STEP="$2"; shift 2 ;;
    *) echo "Unknown argument: $1" >&2; exit 1 ;;
  esac
done

[[ "$STEP" == "prepare" || "$STEP" == "finalise" ]] || { echo "Error: --step prepare|finalise required"; exit 1; }
[[ "$$ STEP" == "prepare" ]] && [[ -z " $${TARGET:-}" ]] && { echo "Error: --target required for prepare"; exit 1; }
MODE="${MODE:-apply}"
[[ "$$ MODE" =~ ^(apply|patch-only) $$ ]] || MODE="apply"

project_root=$(git rev-parse --show-toplevel 2>/dev/null || pwd)
state_dir="$project_root"

if [[ "$STEP" == "prepare" ]]; then
  tmpdir=$$ (mktemp -d " $${project_root}/.robust-edit-tmp.XXXXXX")
  original_path=$(realpath "$TARGET" 2>/dev/null || echo "$project_root/$TARGET")

  echo "$tmpdir" > "$state_dir/.robust-edit-last-tmp"
  echo "$original_path" > "$state_dir/.robust-edit-last-target"
  echo "$MODE" > "$state_dir/.robust-edit-last-mode"

  if Read "$original_path" >/dev/null 2>&1; then
    cp "$original_path" "$tmpdir/file.orig"
  else
    touch "$tmpdir/file.orig"   # new file
  fi
  cp "$tmpdir/file.orig" "$tmpdir/file.modified"

  # Immediate CRLF → LF normalisation
  dos2unix "$tmpdir/file.orig" "$tmpdir/file.modified" 2>/dev/null || \
    perl -pi -e 's/\r$//' "$tmpdir/file.orig" "$tmpdir/file.modified" || true

  echo "Temporary file ready for editing:"
  echo "$tmpdir/file.modified"
  echo "When all edits are complete, run:"
  echo "bash scripts/robust_edit.sh --step finalise"
  exit 0
fi

# === STEP finalise ===
tmpdir=$(cat "$state_dir/.robust-edit-last-tmp")
original_path=$(cat "$state_dir/.robust-edit-last-target")
MODE=$(cat "$state_dir/.robust-edit-last-mode")
dirname=$(dirname "$original_path")
basename=$(basename "$original_path")

# Robustness loop – fix literal \\n (max 3 attempts)
attempt=0
while (( attempt++ < 3 )); do
  if [[ -s "$tmpdir/file.orig" ]]; then
    diff -u -L "a/$basename" -L "b/$basename" \
      "$tmpdir/file.orig" "$tmpdir/file.modified"
  else
    diff -u /dev/null "$tmpdir/file.modified" -L "a/$basename" -L "b/$basename"
  fi > "$tmpdir/patch.diff" || touch "$tmpdir/patch.diff"

  if grep -q '\\\\n' "$tmpdir/patch.diff"; then
    sed -i 's/\\\\n/\n/g' "$tmpdir/file.modified"
    continue
  fi
  break
done

# Validate
if ! (cd "$dirname" && git apply --check "$tmpdir/patch.diff"); then
  echo "FAILED: Patch does not apply cleanly" >&2
  cat "$tmpdir/patch.diff" >&2
  rm -rf "$tmpdir"
  exit 1
fi

# Apply (if apply mode)
if [[ "$MODE" == "apply" ]]; then
  (cd "$dirname" && git apply "$tmpdir/patch.diff") || {
    echo "FAILED: Conflict during apply" >&2
    rm -rf "$tmpdir"
    exit 1
  }
fi

# Save traceable patch
timestamp=$(date +%Y%m%d-%H%M%S)
patch_path="$$ dirname/ $${basename%.*}-$timestamp.patch"
cp "$tmpdir/patch.diff" "$patch_path"

# Cleanup
rm -rf "$tmpdir"
rm -f "$state_dir/.robust-edit-last-"*

# Mandatory final report
echo "Status: SUCCESS"
echo "Saved patch: $patch_path"
echo "```diff
cat "$patch_path"
echo "```"
echo "Confirmation excerpt from $original_path:"
Read "$original_path" | head -n 20
[[ $(Read "$original_path" | wc -l) -gt 20 ]] && echo "... (truncated)"
