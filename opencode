#!/bin/bash

# Define variables
IMAGE="trusted/opencode:latest"

# Error handling
set -e
set -x

# Function to display error messages
error_exit() {
    echo "Error: $1" >&2
    if echo "$1" | grep -q "Permission denied\|Pasta failed"; then
        echo "Rootless Podman storage permission issue. Run: sudo chown -R $USER: /var/cache/$UID/containers/storage && sudo chmod -R 755 /var/cache/$UID/containers/storage"
    fi
    exit 1
}

# Check if the container image exists
if ! podman image exists "$IMAGE"; then
    error_exit "Opencode container image not found. Please run the installation script again."
fi

# Check for aardvark-dns
command -v aardvark-dns >/dev/null || echo "Warning: aardvark-dns not found; custom DNS may fail. Install via package manager."

# Check rootless netns directory permissions
ROOTLESS_DIR="/var/cache/$UID/containers/storage/networks/rootless-netns"
if [ ! -d "$ROOTLESS_DIR" ]; then
  mkdir -p "$ROOTLESS_DIR" || error_exit "Failed to create $ROOTLESS_DIR"
fi
if [ ! -w "$ROOTLESS_DIR" ]; then
  error_exit "Permission denied on $ROOTLESS_DIR. Run: sudo chown -R $USER: /var/cache/$UID/containers/storage && sudo chmod -R 755 /var/cache/$UID/containers/storage"
fi

# Check if stdin is a TTY and set flags accordingly
TTY_FLAG=""
if [ -t 0 ] && [ -t 1 ]; then
    TTY_FLAG="-it"
else
    TTY_FLAG="-i"
fi

# Ensure cache directory exists
mkdir -p "$HOME/.config/zide/log/opencode"

# Ensure Serena config directory and file exist on host
mkdir -p "$HOME/.config/zide/config/opencode/mcps"
touch "$HOME/.config/zide/config/opencode/mcps/serena_config.yml"

# Prepare volume mounts
MOUNTS="-v \"$PWD:/home/node/project:Z\" -v \"$HOME/.config/zide/log/opencode:/home/node/.local/share/opencode:Z\" -v \"$HOME/.config/zide/config/opencode/mcps/serena_config.yml:/home/node/.serena/serena_config.yml:Z\""

# Handle OPENCODE_CONFIG
CONFIG_MOUNT=""
CONFIG_ENV=""
if [ -n "${OPENCODE_CONFIG:-}" ]; then
  if [ -e "$OPENCODE_CONFIG" ]; then
    HOST_DIR=$(dirname "$OPENCODE_CONFIG")
    MOUNT_PATH="/home/node/.config/opencode"
    CONFIG_MOUNT="-v \"$HOST_DIR:$MOUNT_PATH:ro,Z\""
    if [ -d "$OPENCODE_CONFIG" ]; then
      CONFIG_ENV="-e OPENCODE_CONFIG=$MOUNT_PATH/opencode.json"
    else
      CONFIG_FILE=$(basename "$OPENCODE_CONFIG")
      CONFIG_ENV="-e OPENCODE_CONFIG=$MOUNT_PATH/$CONFIG_FILE"
    fi
  else
    error_exit "OPENCODE_CONFIG path does not exist"
  fi
fi

NETWORK_NAME="opencode-net"

# Create network if not exists
if ! podman network exists "$NETWORK_NAME"; then
  if podman network create "$NETWORK_NAME"; then
    :
  else
    echo "Warning: Failed to create network $NETWORK_NAME, using host as fallback"
    NETWORK_NAME="host"
  fi
fi

# Test network
if [ "$NETWORK_NAME" != "host" ] && ! podman run --rm --network="$NETWORK_NAME" --userns=keep-id busybox wget -q --spider http://example.com &>/dev/null; then
  echo "Hardened fallback: Using host network due to connectivity error."
  NETWORK_NAME="host"
fi

CONTAINER_NAME="opencode-server"

# Default values
PORT=4096
HOSTNAME="0.0.0.0"
CLIENT_HOST="localhost"

# Determine if serve is in args and collect NEW_ARGS
SERVER_MODE=false
NEW_ARGS=()
while [ $# -gt 0 ]; do
  arg="$1"
  if [ "$arg" == "serve" ]; then
    SERVER_MODE=true
  elif [ "$arg" == "--port" ]; then
    PORT="$2"
    shift
  elif [ "$arg" == "--hostname" ]; then
    HOSTNAME="$2"
    CLIENT_HOST="$HOSTNAME"
    shift
  else
    NEW_ARGS+=("$arg")
  fi
  shift
done

# Determine attach mode
ATTACH_MODE=false
if [ ${#NEW_ARGS[@]} -eq 0 ] && [ "$SERVER_MODE" != "true" ]; then
  ATTACH_MODE=true
elif [ ${#NEW_ARGS[@]} -gt 0 ] && [ "${NEW_ARGS[0]}" == "attach" ]; then
  ATTACH_MODE=true
fi

# Define known API keys and warn if unset
KNOWN_API_KEYS=("XAI_API_KEY" "ANTHROPIC_API_KEY" "OPENAI_API_KEY" "GEMINI_API_KEY" "GROQ_API_KEY" "OPENROUTER_API_KEY")
for key in "${KNOWN_API_KEYS[@]}"; do
  if [ -z "${!key:-}" ] && ! podman secret exists "opencode_${key}"; then
    echo "Warning: $key is not set; opencode may not work with this provider."
  fi
done

# Prepare secrets
SECRETS=""
for key in "${KNOWN_API_KEYS[@]}"; do
  if podman secret exists "opencode_${key}" 2>/dev/null; then
    SECRETS+=" --secret opencode_${key},type=env,target=${key}"
  fi
done

# Start server if not running
STARTED_SERVER=false
if [ "$ATTACH_MODE" = true ]; then
  podman stop "$CONTAINER_NAME" >/dev/null 2>&1 || true
  podman rm -f "$CONTAINER_NAME" >/dev/null 2>&1 || true
  STARTED_SERVER=true
elif ! podman ps -q --filter name="$CONTAINER_NAME" --filter status=running | grep -q . ; then
  STARTED_SERVER=true
fi

if [ "$STARTED_SERVER" = true ]; then
  if [ "$HOSTNAME" == "0.0.0.0" ]; then
    CLIENT_HOST="localhost"
  fi
  # Check for serena mode and use installed path for startup
  if [ ${#NEW_ARGS[@]} -gt 0 ] && [ "${NEW_ARGS[0]}" == "serena" ]; then
    # Fix for Serena startup: Use the installed path in the container for persistence and to avoid uvx dependency
    # This ensures config persistence via the mounted volume and consistent launching
    SERVER_CMD="podman run -d --replace --name \"$CONTAINER_NAME\" --network \"$NETWORK_NAME\" --publish $PORT:$PORT --userns=keep-id --security-opt=label=disable --cap-drop=ALL --cap-add=NET_BIND_SERVICE $MOUNTS $CONFIG_MOUNT $CONFIG_ENV $SECRETS -e USER=\"$USER\" \"$IMAGE\" /opt/serena-venv/bin/serena start-mcp-server \"${NEW_ARGS[@]:1}\""
  # Check for sqlite-mcp mode
  elif [ ${#NEW_ARGS[@]} -gt 0 ] && [ "${NEW_ARGS[0]}" == "sqlite-mcp" ]; then
    # Reroute to sqlite-mcp-server-enhanced with default db-path
    SERVER_CMD="podman run -d --replace --name \"$CONTAINER_NAME\" --network \"$NETWORK_NAME\" --publish $PORT:$PORT --userns=keep-id --security-opt=label=disable --cap-drop=ALL --cap-add=NET_BIND_SERVICE $MOUNTS $CONFIG_MOUNT $CONFIG_ENV $SECRETS -e USER=\"$USER\" \"$IMAGE\" python -m sqlite_mcp_server_enhanced.start_sqlite_mcp --db-path /home/node/project/mcp.db \"${NEW_ARGS[@]:1}\""
  else
    # Default opencode serve command
    SERVER_CMD="podman run -d --replace --name \"$CONTAINER_NAME\" --network \"$NETWORK_NAME\" --publish $PORT:$PORT --userns=keep-id --security-opt=label=disable --cap-drop=ALL --cap-add=NET_BIND_SERVICE $MOUNTS $CONFIG_MOUNT $CONFIG_ENV $SECRETS -e USER=\"$USER\" \"$IMAGE\" serve --hostname \"$HOSTNAME\" --port $PORT"
    if [ "$SERVER_MODE" = true ] && [ ${#NEW_ARGS[@]} -gt 0 ]; then
      SERVER_CMD="$SERVER_CMD \"${NEW_ARGS[@]}\""
    fi
  fi
  if ! eval "$SERVER_CMD" 2>&1 | tee /tmp/opencode_err.log; then
    ERR=$(cat /tmp/opencode_err.log)
    rm /tmp/opencode_err.log
    echo "$ERR"
    echo "Hardened fallback: Using host network due to error."
    NETWORK_NAME="host"
    # Fallback command, similarly check for serena or sqlite-mcp
    if [ ${#NEW_ARGS[@]} -gt 0 ] && [ "${NEW_ARGS[0]}" == "serena" ]; then
      SERVER_CMD="podman run -d --replace --name \"$CONTAINER_NAME\" --net host --userns=keep-id --security-opt=label=disable --cap-drop=ALL --cap-add=NET_BIND_SERVICE $MOUNTS $CONFIG_MOUNT $CONFIG_ENV $SECRETS -e USER=\"$USER\" \"$IMAGE\" /opt/serena-venv/bin/serena start-mcp-server \"${NEW_ARGS[@]:1}\""
    elif [ ${#NEW_ARGS[@]} -gt 0 ] && [ "${NEW_ARGS[0]}" == "sqlite-mcp" ]; then
      SERVER_CMD="podman run -d --replace --name \"$CONTAINER_NAME\" --net host --userns=keep-id --security-opt=label=disable --cap-drop=ALL --cap-add=NET_BIND_SERVICE $MOUNTS $CONFIG_MOUNT $CONFIG_ENV $SECRETS -e USER=\"$USER\" \"$IMAGE\" python -m sqlite_mcp_server_enhanced.start_sqlite_mcp --db-path /home/node/project/mcp.db \"${NEW_ARGS[@]:1}\""
    else
      SERVER_CMD="podman run -d --replace --name \"$CONTAINER_NAME\" --net host --userns=keep-id --security-opt=label=disable --cap-drop=ALL --cap-add=NET_BIND_SERVICE $MOUNTS $CONFIG_MOUNT $CONFIG_ENV $SECRETS -e USER=\"$USER\" \"$IMAGE\" serve --hostname \"$HOSTNAME\" --port $PORT"
      if [ "$SERVER_MODE" = true ] && [ ${#NEW_ARGS[@]} -gt 0 ]; then
        SERVER_CMD="$SERVER_CMD \"${NEW_ARGS[@]}\""
      fi
    fi
    eval "$SERVER_CMD" || error_exit "Failed to start server even with host"
  fi
fi

# Echo message if started server
if [ "$STARTED_SERVER" = true ]; then
  echo "Server at http://${CLIENT_HOST}:$PORT (API docs at /doc)"
fi

# If only serve was requested (NEW_ARGS empty and SERVER_MODE true), exit
if [ "$SERVER_MODE" = true ] && [ ${#NEW_ARGS[@]} -eq 0 ]; then
  echo "Opencode server started."
  exit 0
fi

# Get server IP for client
if [ "$NETWORK_NAME" == "host" ]; then
  SERVER_IP="127.0.0.1"
elif [ "$NETWORK_NAME" == "bridge" ]; then
  SERVER_IP="localhost"
else
  SERVER_IP=$(podman inspect "$CONTAINER_NAME" --format "{{.NetworkSettings.Networks.$NETWORK_NAME.IPAddress}}")
  if [ -z "$SERVER_IP" ]; then
    error_exit "Failed to get server IP"
  fi
fi

# Run the client
if [ ${#NEW_ARGS[@]} -eq 1 ] && [ "${NEW_ARGS[0]}" == "--version" ] || [ "${NEW_ARGS[0]}" == "--help" ]; then
  eval podman run --rm $TTY_FLAG \
    --userns=keep-id --security-opt=label=disable --network=none \
    $MOUNTS $CONFIG_MOUNT $CONFIG_ENV \
    $SECRETS -e USER="$USER" \
    "$IMAGE" "${NEW_ARGS[@]}"
else
  if [ ${#NEW_ARGS[@]} -eq 0 ]; then
    eval podman run --rm $TTY_FLAG \
      --network "$NETWORK_NAME" \
      --userns=keep-id --security-opt=label=disable \
      $MOUNTS $CONFIG_MOUNT $CONFIG_ENV \
      $SECRETS -e USER="$USER" \
      "$IMAGE" attach "http://$SERVER_IP:$PORT"
  else
    eval podman run --rm $TTY_FLAG \
      --network "$NETWORK_NAME" \
      --userns=keep-id --security-opt=label=disable \
      $MOUNTS $CONFIG_MOUNT $CONFIG_ENV \
      $SECRETS -e USER="$USER" \
      "$IMAGE" "${NEW_ARGS[@]}"
  fi
  echo "Connect programmatically via API at http://${CLIENT_HOST}:$PORT"
fi
