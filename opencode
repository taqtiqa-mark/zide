#!/bin/bash

# Define variables
IMAGE="trusted/opencode:latest"

# Error handling
set -e
set -x

# Function to display error messages
error_exit() {
    echo "Error: $1" >&2
    if echo "$1" | grep -q "Permission denied\|Pasta failed"; then
        echo "Rootless Podman storage permission issue. Run: sudo chown -R $USER: /var/cache/$UID/containers/storage && sudo chmod -R 755 /var/cache/$UID/containers/storage"
    fi
    exit 1
}

# Check if the container image exists
if ! podman image exists "$IMAGE"; then
    error_exit "Opencode container image not found. Please run the installation script again."
fi

# Check for aardvark-dns
command -v aardvark-dns >/dev/null || echo "Warning: aardvark-dns not found; custom DNS may fail. Install via package manager."

# Check rootless netns directory permissions
ROOTLESS_DIR="/var/cache/$UID/containers/storage/networks/rootless-netns"
if [ ! -d "$ROOTLESS_DIR" ]; then
  mkdir -p "$ROOTLESS_DIR" || error_exit "Failed to create $ROOTLESS_DIR"
fi
if [ ! -w "$ROOTLESS_DIR" ]; then
  error_exit "Permission denied on $ROOTLESS_DIR. Run: sudo chown -R $USER: /var/cache/$UID/containers/storage && sudo chmod -R 755 /var/cache/$UID/containers/storage"
fi

# Check if stdin is a TTY and set flags accordingly
TTY_FLAG=""
if [ -t 0 ] && [ -t 1 ]; then
    TTY_FLAG="-it"
else
    TTY_FLAG="-i"
fi

# Ensure cache directory exists
mkdir -p "$HOME/.config/zide/log/opencode"

# Ensure Serena config directory and file exist on host
mkdir -p "$HOME/.config/zide/config/opencode/mcps"
touch "$HOME/.config/zide/config/opencode/mcps/serena_config.yml"

# Ensure optional persistent directories exist
for dir in "$PWD/.serena" "$PWD/.beads" "$PWD/.rustup" "$PWD/.cargo" "$HOME/go"; do
  if [ ! -d "$dir" ]; then
    mkdir -p "$dir" || echo "Warning: Failed to create $dir for persistence."
  fi
done

# Prepare volume mounts with persistent Serena config and caches
MOUNTS="-v \"$PWD:/home/node/project:Z\" -v \"$HOME/.config/zide/log/opencode:/home/node/.local/share/opencode:Z\" -v \"$HOME/.config/zide/config/opencode/AGENTS.md:/home/node/.config/opencode/AGENTS.md:Z\" -v \"$HOME/.config/zide/log/serena:/home/node/.serena/logs:Z\" -v \"$HOME/.config/zide/config/opencode/mcps/serena_config.yml:/home/node/.serena/serena_config.yml:Z\""
[ -d "$PWD/go" ] && MOUNTS+=" -v \"$PWD/go:/home/node/go:Z\""
[ -d "$PWD/.rustup" ] && MOUNTS+=" -v \"$PWD/.rustup:/home/node/.rustup:Z\""
[ -d "$PWD/.cargo" ] && MOUNTS+=" -v \"$PWD/.cargo:/home/node/.cargo:Z\""

# Project initialization
echo "Initializing project with .opencode/templates..."
SOURCE_DIR="$HOME/.config/zide/config/opencode/.specify/templates"
TARGET_DIR="$PWD/.specify/templates"

if [ ! -d "$SOURCE_DIR" ]; then
    echo "Warning: Source templates directory not found, skipping initialization."
else
    if [ -d "$TARGET_DIR" ]; then
        echo "Project already initialized with .opencode/templates."
    else
        mkdir -p "$TARGET_DIR" || error_exit "Failed to create .opencode/templates directory."
        cp -r "$SOURCE_DIR/." "$TARGET_DIR/" || error_exit "Failed to copy templates."
        echo "Project initialized successfully."
    fi
fi

# Handle OPENCODE_CONFIG
CONFIG_MOUNT=""
CONFIG_ENV=""
if [ -n "${OPENCODE_CONFIG:-}" ]; then
  if [ -e "$OPENCODE_CONFIG" ]; then
    HOST_DIR=$(dirname "$OPENCODE_CONFIG")
    MOUNT_PATH="/home/node/.config/opencode"
    CONFIG_MOUNT="-v \"$HOST_DIR:$MOUNT_PATH:rw,Z\""
    if [ -d "$OPENCODE_CONFIG" ]; then
      CONFIG_ENV="-e OPENCODE_CONFIG=$MOUNT_PATH/opencode.json"
    else
      CONFIG_FILE=$(basename "$OPENCODE_CONFIG")
      CONFIG_ENV="-e OPENCODE_CONFIG=$MOUNT_PATH/$CONFIG_FILE"
    fi
  else
    error_exit "OPENCODE_CONFIG path does not exist"
  fi
fi

# Network setup section:
# This section handles the creation and testing of a custom network for the container.
# It attempts to create a dedicated network for isolation and connectivity.
# If creation fails or connectivity test fails, it falls back to the host network.
# To extend for other MCP servers (e.g., Serena):
# - Modify NETWORK_NAME to a unique name if multiple networks are needed.
# - Add custom network options (e.g., --subnet) in podman network create for specific MCP requirements.
# - For MCP servers requiring specific ports or protocols, adjust the connectivity test (e.g., test MCP-specific endpoints).
# - Ensure fallback to 'host' maintains MCP stdio/HTTP compatibility without breaking existing opencode behavior.
NETWORK_NAME="opencode-net"

# Create network if not exists
if ! podman network exists "$NETWORK_NAME"; then
  if podman network create "$NETWORK_NAME"; then
    :
  else
    echo "Warning: Failed to create network $NETWORK_NAME, using host as fallback"
    NETWORK_NAME="host"
  fi
fi

# Test network
if [ "$NETWORK_NAME" != "host" ] && ! podman run --rm --network="$NETWORK_NAME" --userns=keep-id busybox wget -q --spider http://example.com &>/dev/null; then
  echo "Hardened fallback: Using host network due to connectivity error."
  NETWORK_NAME="host"
fi

CONTAINER_NAME="opencode-server"

# Default values
PORT=4096
HOSTNAME="0.0.0.0"
CLIENT_HOST="localhost"

# Determine if serve is in args and collect NEW_ARGS
SERVER_MODE=false
NEW_ARGS=()
while [ $# -gt 0 ]; do
  arg="$1"
  if [ "$arg" == "serve" ]; then
    SERVER_MODE=true
  elif [ "$arg" == "--port" ]; then
    PORT="$2"
    shift
  elif [ "$arg" == "--hostname" ]; then
    HOSTNAME="$2"
    CLIENT_HOST="$HOSTNAME"
    shift
  else
    NEW_ARGS+=("$arg")
  fi
  shift
done

# Determine attach mode
ATTACH_MODE=false
if [ ${#NEW_ARGS[@]} -eq 0 ] && [ "$SERVER_MODE" != "true" ]; then
  ATTACH_MODE=true
elif [ ${#NEW_ARGS[@]} -gt 0 ] && [ "${NEW_ARGS[0]}" == "attach" ]; then
  ATTACH_MODE=true
fi

# Define known API keys and warn if unset
KNOWN_API_KEYS=("XAI_API_KEY" "ANTHROPIC_API_KEY" "OPENAI_API_KEY" "GEMINI_API_KEY" "GROQ_API_KEY" "OPENROUTER_API_KEY")
for key in "${KNOWN_API_KEYS[@]}"; do
  if [ -z "${!key:-}" ] && ! podman secret exists "opencode_${key}"; then
    echo "Warning: $key is not set; opencode may not work with this provider."
  fi
done

# Prepare secrets
SECRETS=""
for key in "${KNOWN_API_KEYS[@]}"; do
  if podman secret exists "opencode_${key}" 2>/dev/null; then
    SECRETS+=" --secret opencode_${key},type=env,target=${key}"
  fi
done

# Subcommand routing section:
# This section checks if the command is a subcommand like 'specify' or 'serena'.
# If so, it runs a temporary (--rm) podman container to execute the tool without starting a persistent server.
# This provides easy access to project-specific CLI tools (e.g., specify init) with isolation and no shared state.
# Paths like '.' are adjusted to '/home/node/project' for container-internal execution.
# Errors are logged using the existing error_exit function.
# For 'specify', run as one-off command; preserves existing server logic for other cases.
if [ ${#NEW_ARGS[@]} -gt 0 ]; then
  SUBCMD="${NEW_ARGS[0]}"
  if [ "$SUBCMD" == "init" ]; then
    if [ -d ".specify" ]; then
      echo "Project already initialized with .specify directory."
    else
      if ! command -v curl >/dev/null || ! command -v unzip >/dev/null; then
        echo "Warning: curl or unzip not available. Skipping initialization."
      else
        ZIP_URL="https://github.com/github/spec-kit/releases/download/v0.0.79/spec-kit-template-opencode-sh-v0.0.79.zip"
        ZIP_FILE="spec-kit-template.zip"
        if curl -L "$ZIP_URL" -o "$ZIP_FILE"; then
          if unzip "$ZIP_FILE"; then
            rm "$ZIP_FILE"
            echo "Project initialized successfully."
          else
            echo "Warning: Failed to unzip the template."
            rm "$ZIP_FILE"
          fi
        else
          echo "Warning: Failed to download the template zip."
        fi
      fi
    fi
    exit 0
  elif [ "$SUBCMD" == "specify" ]; then
    if [ ${#NEW_ARGS[@]} -ge 3 ] && [ "${NEW_ARGS[1]}" == "init" ] && [ "${NEW_ARGS[2]}" == "--here" ]; then
      if [ -d ".specify" ]; then
        echo "Project already initialized with .specify directory."
      else
        if ! command -v curl >/dev/null || ! command -v unzip >/dev/null; then
          echo "Warning: curl or unzip not available. Skipping initialization."
        else
          ZIP_URL="https://github.com/github/spec-kit/releases/download/v0.0.79/spec-kit-template-opencode-sh-v0.0.79.zip"
          ZIP_FILE="spec-kit-template.zip"
          if curl -L "$ZIP_URL" -o "$ZIP_FILE"; then
            if unzip "$ZIP_FILE"; then
              rm "$ZIP_FILE"
              echo "Project initialized successfully."
            else
              echo "Warning: Failed to unzip the template."
              rm "$ZIP_FILE"
            fi
          else
            echo "Warning: Failed to download the template zip."
          fi
        fi
      fi
      exit 0
    else
      # Adjust paths in arguments (e.g., replace '.' with '/home/node/project')
      ADJUSTED_ARGS=("${NEW_ARGS[@]:1}")
      for i in "${!ADJUSTED_ARGS[@]}"; do
        if [ "${ADJUSTED_ARGS[$i]}" == "." ]; then
          ADJUSTED_ARGS[$i]="/home/node/project"
        fi
      done
      if [[ "$SUBCMD" == "specify" ]]; then PATH_EXTENSION='-e PATH='\''/home/node/.uv/tools/specify-cli/bin:/usr/local/bin:/usr/local/sbin:/usr/bin:/usr/sbin:/bin:/sbin'\'''; else PATH_EXTENSION=""; fi
      eval podman run --rm $TTY_FLAG         --entrypoint specify         --network "$NETWORK_NAME"         --userns=keep-id --security-opt=label=disable         $MOUNTS $CONFIG_MOUNT $CONFIG_ENV         $SECRETS $PATH_EXTENSION -e USER="$USER"         "$IMAGE" "${ADJUSTED_ARGS[@]}" || error_exit "Failed to run specify subcommand"
      exit 0
    fi
  elif [ "$SUBCMD" == "serena" ]; then
    # Existing serena handling (as server), but if it's CLI-like, could adjust to --rm if needed
    # For now, preserve as is
    :
  fi
fi

# Start server if not running
STARTED_SERVER=false
if [ "$ATTACH_MODE" = true ]; then
  podman stop "$CONTAINER_NAME" >/dev/null 2>&1 || true
  podman rm -f "$CONTAINER_NAME" >/dev/null 2>&1 || true
  STARTED_SERVER=true
elif ! podman ps -q --filter name="$CONTAINER_NAME" --filter status=running | grep -q . ; then
  STARTED_SERVER=true
fi

# Server startup section:
# This section constructs and executes the SERVER_CMD to start the opencode-server container.
# It handles forced restarts for attach mode and fallback to host network on errors.
# To extend for other MCP servers (e.g., Serena):
# - Modify SERVER_CMD to include alternative entrypoints or commands (e.g., replace 'serve' with 'serena start-mcp-server' for Serena integration).
# - Add MCP-specific flags or environment variables (e.g., -e SERENA_CONTEXT=ide-assistant) without altering existing opencode logic.
# - For modes, append custom args to SERVER_CMD based on SERVER_MODE (e.g., add --mode planning for Serena modes).
# - Ensure fallback logic preserves original behavior; test that opencode 'serve' remains unchanged.
# - To add new entrypoints, conditionally build SERVER_CMD based on NEW_ARGS (e.g., if NEW_ARGS includes 'serena', reroute to Serena command).
if [ "$STARTED_SERVER" = true ]; then
  if [ "$HOSTNAME" == "0.0.0.0" ]; then
    CLIENT_HOST="localhost"
  fi
  # Retry logic
  SERVER_CMD="podman run -d --replace --name \"$CONTAINER_NAME\" --network \"$NETWORK_NAME\" --publish $PORT:$PORT --userns=keep-id --security-opt=label=disable --cap-drop=ALL --cap-add=NET_BIND_SERVICE $MOUNTS $CONFIG_MOUNT $CONFIG_ENV $SECRETS -e USER=\"$USER\" \"$IMAGE\" serve --hostname \"$HOSTNAME\" --port $PORT"
  if [ "$SERVER_MODE" = true ] && [ ${#NEW_ARGS[@]} -gt 0 ]; then
    SERVER_CMD="$SERVER_CMD \"${NEW_ARGS[@]}\""
  fi
  if ! eval "$SERVER_CMD" 2>&1 | tee /tmp/opencode_err.log; then
    ERR=$(cat /tmp/opencode_err.log)
    rm /tmp/opencode_err.log
    echo "$ERR"
    echo "Hardened fallback: Using host network due to error."
    NETWORK_NAME="host"
    SERVER_CMD="podman run -d --replace --name \"$CONTAINER_NAME\" --net host --userns=keep-id --security-opt=label=disable --cap-drop=ALL --cap-add=NET_BIND_SERVICE $MOUNTS $CONFIG_MOUNT $CONFIG_ENV $SECRETS -e USER=\"$USER\" \"$IMAGE\" serve --hostname \"$HOSTNAME\" --port $PORT"
    if [ "$SERVER_MODE" = true ] && [ ${#NEW_ARGS[@]} -gt 0 ]; then
      SERVER_CMD="$SERVER_CMD \"${NEW_ARGS[@]}\""
    fi
    eval "$SERVER_CMD" || error_exit "Failed to start server even with host"
  fi
fi

# Echo message if started server
if [ "$STARTED_SERVER" = true ]; then
  echo "Server at http://${CLIENT_HOST}:$PORT (API docs at /doc)"
fi

# If only serve was requested (NEW_ARGS empty and SERVER_MODE true), exit
if [ "$SERVER_MODE" = true ] && [ ${#NEW_ARGS[@]} -eq 0 ]; then
  echo "Opencode server started."
  exit 0
fi

# Get server IP for client
if [ "$NETWORK_NAME" == "host" ]; then
  SERVER_IP="127.0.0.1"
elif [ "$NETWORK_NAME" == "bridge" ]; then
  SERVER_IP="localhost"
else
  SERVER_IP=$(podman inspect "$CONTAINER_NAME" --format "{{.NetworkSettings.Networks.$NETWORK_NAME.IPAddress}}")
  if [ -z "$SERVER_IP" ]; then
    error_exit "Failed to get server IP"
  fi
fi

# Command execution section:
# This section runs the client container based on parsed arguments (e.g., attach, version, help).
# It handles special cases like --version/--help with network=none, and defaults to attach if no args.
# To extend for other MCP servers (e.g., Serena):
# - Add conditional logic based on NEW_ARGS to exec alternative commands (e.g., if NEW_ARGS[0] == 'serena', replace "\"$IMAGE\" \"${NEW_ARGS[@]}\"" with Serena-specific podman run).
# - For modes or entrypoints, parse additional flags in the while loop and adjust the eval command accordingly.
# - Ensure existing behaviors (e.g., attach to opencode-server) remain unchanged; extensions should be opt-in via specific args.
# - For MCP HTTP mode, modify --network and add port mappings if needed, without affecting stdio-based commands.
# Run the client
if [ ${#NEW_ARGS[@]} -eq 1 ] && [ "${NEW_ARGS[0]}" == "--version" ] || [ "${NEW_ARGS[0]}" == "--help" ]; then
  eval podman run --rm $TTY_FLAG \
    --userns=keep-id --security-opt=label=disable --network=none \
    $MOUNTS $CONFIG_MOUNT $CONFIG_ENV \
    $SECRETS -e USER="$USER" \
    "$IMAGE" "${NEW_ARGS[@]}"
else
  if [ ${#NEW_ARGS[@]} -eq 0 ]; then
    eval podman run --rm $TTY_FLAG \
      --network "$NETWORK_NAME" \
      --userns=keep-id --security-opt=label=disable \
      $MOUNTS $CONFIG_MOUNT $CONFIG_ENV \
      $SECRETS -e USER="$USER" \
      "$IMAGE" attach "http://$SERVER_IP:$PORT"
  else
    eval podman run --rm $TTY_FLAG \
      --network "$NETWORK_NAME" \
      --userns=keep-id --security-opt=label=disable \
      $MOUNTS $CONFIG_MOUNT $CONFIG_ENV \
      $SECRETS -e USER="$USER" \
      "$IMAGE" "${NEW_ARGS[@]}"
  fi
  echo "Connect programmatically via API at http://${CLIENT_HOST}:$PORT"
fi
